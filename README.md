저번 시간 내용 이어서 코드 짜기
아직 나에게는 조금 버거운 것 같은 느낌이 들긴 하다...
그래도 파이팅 
매우 간단한 라이브러리인 익스프레스를 사용한다.
근데 이 코드는 너무 자유로운 라이브러리이기 때문에 오히려 제공하는 것이 적다 > 이를 보완하기 위해서 nest를 만들게 되었다.
왜 만들었는가를 파악하는 것은 중요하다

아키텍쳐를 효율적으로 풀어내기 위해서 사용하는 것
아직까지는 벡엔드에서 아키텍쳐를 잘 사용하도록 도와주는 라이브러리가 만들어져 있지 않았다는 판단 하에 프레임 워크를 만들게 된 것이다.
여기서 말하는 아키텍쳐란?

nest의 구성요소
타임 스크립트라는 것에 익숙해져야한다. > 수월하게 다룰 수 있어야 이 스터디를 따라갈 수 있음 > 저번 시간에 한 것

이게 뭐야!!!! 뭘 하신거지....?

배웠던 put delete get post
경로에 따라서 해당하는 경로의 메소드를 호출해서 사용한다.
파란 바디 쿼리
경로 말고 추가적인 데이터를 받을 때 사용하게 된다.
먼소리여

포스트 맨이 도움이 된다고/?
로컬 호스트는 자기 자신 아이디를 뜻합니다. 

쿼리를 추가해서 뭘 하신다는 것 같은데 지금 뭔지를 모르겟넹
쿼리 사용 방법을 보여주신 것 같은데 
프레임워크 사용 이유를 알려주시려고 하는 것 같은데....

@뒤의 것들은 데코레이터라고 하고 지금 사용하려고 하는 것이 무엇인지 알려주는 것이라고 보면 된다. 카테고라이징 하는거지
이런 식으로 계산기를 만들어 쓰기도 한다.
얘들 그대로 가져와서 사용한다고 보면 된다.
인젝터블이 붙은 모든 클래스는 프로바이더다!
이 프로바이더는 다양한 기능을 추가할 수 있는 기능이다.

컨트롤러와 서비스를 나눠놓은 이유

컨트롤러 > 라우트를 처리하는 데에 큰 중심 , 내부적으로 뭔가 하는 것이라기보다는, 핵심 로직들을 api에 따라 처리하는 기능을 하게 되는 것이다.
 *의존성 주입이란
클래스 a 와 클래스 b가 있지
b안에서 a의 객체를 가지고 있잖아?
이때 b가 a를 의존한다고 말할 수 있다.
b는 a가 무엇인지, 어떤 역할을 하는지 알고 있어야 한다.
b안에서 a의 객체를 만들던지 밖에서 만들던지 다 가능한데 
밖에서 만들어진 것을 안으로 가져와서 사용하는 경우 (위의 사진과 같이) 의존성 주입이라고 한다.
위의 사진에서 정의만 필요하다 새로 const를 사용해서 new a,b를 만들어줄 필요가 없다. 이것이 이것을 사용하는 이유가 된다.
a는 b를 의존성 객체로 갖는다.

강 결합, 약 결합
강 결합: 슨 역할인지 알아야 하는 경우
약 결합: 인터페이스를 사용할 때 많이 이용 > 무슨 일, 역할을 하는지 알 필요가 없다. 위의 사진과 같은 경우가 예시가 된다. 
스프링도 기본적으로 내부적인 의존성 주입을 기반으로 하는 걸로 알고 있음
캡슐화 이기 때문에 밖에서 생성된 묘듈을 가져와서 쓰려면 다른 방법이 필요하다. 
모듈 decorator는 네 가지 종류가 있다.
provider
imports
controller
exports
얘네들에 해당하는 내용들은 누락 없이 다! 넣어줘야 한다.
용량이 많아지면 실수하는 경우도 생기는데 안돼! 다 넣어줘야 한다.
에러는 안 난다. 빌드도 된다. 그래서 더 문제 무엇이 빠졌는지를 알 수 없어 .켜면 서버가 정상적으로 켜지질 않아 >> 누락이 된 것이다.
모듈에다 내가 지금 사용하고 있는 모든 
provider 
imports
controller
exports
모두 넣어야 해

묘듈의 캡슐화 떄문에 가져와서 사용하지 못하는 경우도 있다.
이것을 해결하기 위한 해결 방법을 알려주시는데..
이게 바로 묘듈에 모든 것들을 넣어두는 것이다. 넣어두어야 다른 곳엑서 가져가서 사용이 가능핟,
여기서 포인트
객체를 사용하지 않고 클래스 이름을 그대로 사용한다!
미들웨어 
next() 호출을 해줘야한다 > 안 해주면 진행 불가라는 것이 포인트
미들웨어도 기본적으로 프로바이더이다. 따라서 인젝터블 안에 써준다
마지막에 next()를 호출해준 것이 눈에 띈다
use 안에 써준 것이 뭔지 궁금하네

예외필터
에러를 처리 
기본적으로 적용되어있는 경우가 있다
만약에 위의 사진에서 밑줄 쳐져 있는 경우처럼 원래 저장되지 않은 에러가 있으면 기본 익셉션 처리가 된다.
근데 커스텀 하게 내보내고 싶으면 이 예외 필터를 사용하면 되는 것이다. 우리가 직접 만든 필터를 통해 받아서 처리되길 바라면 !!
직접 new사용하는 경우 > nest밖에 있는 경우

파이프

value에 값이 들어온다

parseIntPipe를 사용하면 문자를 숫자로 변환하여 받을 수 있다
유용한 친구
validationPipe
유용한지 아닌지를 파악하는 역할을 한다

가드


가드는 안에서 비동기 처리가 가능하다.
사용하는 예시 : 이 유저가 정말로 이 api 에 접근할 수 있는 유저인지 확인 >> 인증, 인가에 사용한다.


트루를 박아놓으면 ...?
post 를 날리면 정상적으로 요청이 들어가서 응답이 오고
get을 날리면 404가 뜬다 > 에러

인터셉터


얘네가 스트림이다
요청을 실제로 처리하는 애가 handle
시간 처리가 들어가기 전에 시간을 파악하고,,,등등의 과정을 거치는 코드가 저 코드이다.

요청 처리 순서

컨트롤러를 기준으로 밑으로는 넓어지는 스코프 위로는 좁아지는 스코프이다. 

가드
요청이 될 수 있는지 없는지 확인한다 .
지나갈 수 있는지 없는지 확인 
얘가 권한을 갖는지 알아야 하잖아?
때문에 canactivate라는 클래스를 갖는다 


기본적으로 네스트 서버는 3000번 포트를 사용한다.
이 서버의 루트패스에 요청을 보내주는 작업 >> 인증 인가를 해준다
false를 반환하면 404가 뜨고 true를 반환하면 

이 사진에 result: 'hello'가 뜨게된다 
에러 메세지를 커스텀 하게 써야할 때가 있단 말이지

기본적으로 이렇게 구성을 많이 한다.

데베 사용을 위해서 async를 앞에 저렇게 덧붙이면 가져와서 사용할 수 있다 
데베 연결해서 사용할 일이 많잖아 나중에 서버가 커지면 

오케 여기 까지 다음시간에 계속

오케 여긲자ㅏ지 다음시간에 계속# susc-study-nestjs
